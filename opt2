def _onehot_panel(self, name: str, categories: list[str]) -> np.ndarray:
    v = np.zeros(len(categories), np.float32)
    if name in categories:
        v[categories.index(name)] = 1.0
    return v

def _build_feature_for_gray_W(self, lut256_norm: dict, g: int,
                              panel_onehot: np.ndarray,
                              frame_rate: float,
                              model_year: float) -> np.ndarray:
    """
    train_Y0_models()에서 쓴 VACDataset.build_per_gray_y0()의 스키마와 동일하게 구성.
    feature = [R_Low[g],R_High[g],G_Low[g],G_High[g],B_Low[g],B_High[g],
               panel_onehot..., frame_rate, model_year,
               gray/255, pattern_onehot(4= 'W','R','G','B')]
    """
    row = [
        float(lut256_norm['R_Low'][g]),  float(lut256_norm['R_High'][g]),
        float(lut256_norm['G_Low'][g]),  float(lut256_norm['G_High'][g]),
        float(lut256_norm['B_Low'][g]),  float(lut256_norm['B_High'][g]),
    ]
    row.extend(panel_onehot.astype(np.float32).tolist())
    row.append(float(frame_rate))
    row.append(float(model_year))
    row.append(g / 255.0)
    # pattern='W' one-hot
    pat_oh = np.array([1.0, 0.0, 0.0, 0.0], dtype=np.float32)
    row.extend(pat_oh.tolist())
    return np.asarray(row, dtype=np.float32)

def _predict_Y0_W(self, lut256_norm: dict,
                  panel_name: str, panel_categories: list[str],
                  frame_rate: float, model_year: float) -> dict[str, np.ndarray]:
    """
    현재 LUT(정규화 0..1) 기준으로 white 패턴의 절대 Gamma/Cx/Cy를 256길이로 예측.
    self.models_Y0_bundle = {"Gamma":payload, "Cx":payload, "Cy":payload} 필요.
    payload는 train_hybrid_regressor의 반환 payload 구조( linear_model, rf_residual, target_scaler ).
    """
    # (a) 메타 인코딩
    panel_oh = self._onehot_panel(panel_name, PANEL_MAKER_CATEGORIES[0])  # ← 앱의 카테고리 리스트 사용

    # (b) 피처 행렬 구성 (256 x Dx)
    X_rows = [ self._build_feature_for_gray_W(lut256_norm, g, panel_oh, frame_rate, model_year)
               for g in range(256) ]
    X = np.vstack(X_rows).astype(np.float32)

    out = {}
    for comp in ("Gamma", "Cx", "Cy"):
        payload = self.models_Y0_bundle[comp]
        lin = payload["linear_model"]
        rf  = payload["rf_residual"]
        ts  = payload.get("target_scaler", {"standardized": True, "mean": 0.0, "std": 1.0})
        # 1단계 + 잔차
        base_s = lin.predict(X).astype(np.float32)
        resid_s = rf.predict(X).astype(np.float32)
        y_s = base_s + resid_s
        # 표준화 역변환
        if ts.get("standardized", True):
            y = y_s * float(ts.get("std", 1.0)) + float(ts.get("mean", 0.0))
        else:
            y = y_s
        out[comp] = y.astype(np.float32)
    return out

def _check_spec_with_prediction_W(self, off_store, pred_on_y0_W: dict[str, np.ndarray],
                                  thr_gamma=0.05, thr_c=0.003) -> bool:
    # OFF baseline (white/main)에서 Gamma/Cx/Cy 시퀀스 추출
    lv_ref = np.zeros(256); cx_ref = np.zeros(256); cy_ref = np.zeros(256)
    for g in range(256):
        tup = off_store['gamma']['main']['white'].get(g, None)
        if tup: lv_ref[g], cx_ref[g], cy_ref[g] = tup
        else:   lv_ref[g]=np.nan; cx_ref[g]=np.nan; cy_ref[g]=np.nan
    G_ref = self._compute_gamma_series(lv_ref)

    # 예측된 ON 절대 (white)
    G_on_pred = pred_on_y0_W["Gamma"]
    Cx_on_pred = pred_on_y0_W["Cx"]
    Cy_on_pred = pred_on_y0_W["Cy"]

    # Δ 계산 (NaN 방어)
    dG  = np.abs(np.nan_to_num(G_on_pred - G_ref, nan=0.0))
    dCx = np.abs(np.nan_to_num(Cx_on_pred - cx_ref, nan=0.0))
    dCy = np.abs(np.nan_to_num(Cy_on_pred - cy_ref, nan=0.0))

    max_dG  = float(np.nanmax(dG))
    max_dCx = float(np.nanmax(dCx))
    max_dCy = float(np.nanmax(dCy))

    logging.info(f"[PRED SPEC] max|ΔGamma|={max_dG:.6f} (≤{thr_gamma}), "
                 f"max|ΔCx|={max_dCx:.6f}, max|ΔCy|={max_dCy:.6f} (≤{thr_c})")
    return (max_dG <= thr_gamma) and (max_dCx <= thr_c) and (max_dCy <= thr_c)


# ----- [NEW] 예측모델로 사전 검증 게이트 -----
try:
    # 정규화(0..1)된 256포인트 LUT 준비 (Low: 캐시에서 다운샘플→/4095, High: 보정후→/4095)
    low_256_norm = {
        "R_Low":  self._down4096_to_256(vac_lut["R_Low"])  / 4095.0,
        "G_Low":  self._down4096_to_256(vac_lut["G_Low"])  / 4095.0,
        "B_Low":  self._down4096_to_256(vac_lut["B_Low"])  / 4095.0,
    }
    high_256_norm = {
        "R_High": (high_256_new["R_High"] / 4095.0).astype(np.float32),
        "G_High": (high_256_new["G_High"] / 4095.0).astype(np.float32),
        "B_High": (high_256_new["B_High"] / 4095.0).astype(np.float32),
    }
    lut256_norm = {**low_256_norm, **high_256_norm}

    # 메타: 패널/주사율/연도 (UI에서 사용 중인 값 재사용)
    panel_name  = self.ui.vac_cmb_PanelMaker.currentText().strip()
    frame_rate  = float(self.ui.vac_cmb_FrameRate.currentText().strip())
    # model_year는 없으면 보수적으로 0 또는 최근 연도로 설정
    try:
        model_year = float(getattr(self, "current_model_year", 0.0))
    except Exception:
        model_year = 0.0

    # 예측
    pred_y0_W = self._predict_Y0_W(
        lut256_norm=lut256_norm,
        panel_name=panel_name,
        panel_categories=PANEL_MAKER_CATEGORIES[0],
        frame_rate=frame_rate,
        model_year=model_year
    )

    # 스펙 게이트
    if self._check_spec_with_prediction_W(self._off_store, pred_y0_W,
                                          thr_gamma=0.05, thr_c=0.003):
        logging.info("[PRED] ✅ 예측 스펙-IN → TV에 적용 진행")
        do_apply = True
    else:
        logging.info("[PRED] ❌ 예측 스펙-OUT → 파라미터 조정(예: λ↑) 후 재시도 또는 스킵")
        # 간단 전략: λ(리지) 증가 후 한 번 더 풀기 → 필요 없으면 False로 그냥 측정 단계로 가도 됨
        # 여기서는 일단 적용을 진행하지 않고, 다음 이터레이션/전략으로 넘기고 싶다면:
        # return  혹은  do_apply = False 로 분기
        do_apply = True  # <- 처음엔 실제 거동 확인 위해 True 유지 권장
except Exception as e:
    logging.exception(f"[PRED] 사전 예측 검증 중 오류: {e}")
    do_apply = True  # 안전하게 계속 진행
# ---------------------------------------------

try:
    models_dir = cf.get_normalized_path(__file__, '.', 'models')
    self.models_Y0_bundle = {
        "Gamma": joblib.load(os.path.join(models_dir, "hybrid_Gamma_model.pkl")),
        "Cx":    joblib.load(os.path.join(models_dir, "hybrid_Cx_model.pkl")),
        "Cy":    joblib.load(os.path.join(models_dir, "hybrid_Cy_model.pkl")),
    }
    logging.info("[Predict] Hybrid Y0 models loaded.")
except Exception as e:
    logging.exception("[Predict] Failed to load Y0 models.")
    self.models_Y0_bundle = None

if not getattr(self, "models_Y0_bundle", None):
    logging.warning("[PRED] Y0 예측모델이 없어 사전 검증을 생략합니다.")


