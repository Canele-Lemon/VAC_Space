    def _predict_Y0W_from_models(self, lut256_dict, *, panel_text, frame_rate, model_year):
        """
        저장된 hybrid_*_model.pkl 3개로 'W' 패턴 256 포인트의 (Gamma, Cx, Cy) 예측 벡터를 생성
        """
        # ✅ LUT는 반드시 0..1 스케일로 맞춘다
        def _norm01(a): 
            return np.clip(np.asarray(a, np.float32) / 4095.0, 0.0, 1.0)
        lut256_norm = {
            "R_Low":  _norm01(lut256_dict["R_Low"]),
            "R_High": _norm01(lut256_dict["R_High"]),
            "G_Low":  _norm01(lut256_dict["G_Low"]),
            "G_High": _norm01(lut256_dict["G_High"]),
            "B_Low":  _norm01(lut256_dict["B_Low"]),
            "B_High": _norm01(lut256_dict["B_High"]),
        }

        # 256행 피처 매트릭스
        # ✅ _build_runtime_feature_row_W의 파라미터명은 model_year_2digit 입니다.
        X_rows = [ self._build_runtime_feature_row_W(
                        lut256_norm, g,
                        panel_text=panel_text,
                        frame_rate=frame_rate,
                        model_year_2digit=float(model_year)  # 두 자리 숫자 가정
                ) for g in range(256) ]
        X = np.vstack(X_rows).astype(np.float32)

        def _pred_one(payload):
            lin = payload["linear_model"]; rf = payload["rf_residual"]
            tgt = payload["target_scaler"]; y_mean = float(tgt["mean"]); y_std = float(tgt["std"])
            base_s  = lin.predict(X).astype(np.float32)
            resid_s = rf.predict(X).astype(np.float32)
            y = (base_s + resid_s) * y_std + y_mean
            return y.astype(np.float32)

        yG  = _pred_one(self.models_Y0_bundle["Gamma"])
        yCx = _pred_one(self.models_Y0_bundle["Cx"])
        yCy = _pred_one(self.models_Y0_bundle["Cy"])

        # Gamma 0/255는 NaN
        yG[0] = np.nan; yG[255] = np.nan
        return {"Gamma": yG, "Cx": yCx, "Cy": yCy}

def _predictive_first_optimize(self, vac_data_json, *, n_iters=2, wG=0.4, wC=1.0, lambda_ridge=1e-3):
    try:
        vac_dict = json.loads(vac_data_json)

        # 1️⃣ 기존 그대로 — 4096→256 다운샘플 (12bit 값 그대로)
        lut256 = {
            "R_Low":  self._down4096_to_256_float(vac_dict["RchannelLow"]),
            "R_High": self._down4096_to_256_float(vac_dict["RchannelHigh"]),
            "G_Low":  self._down4096_to_256_float(vac_dict["GchannelLow"]),
            "G_High": self._down4096_to_256_float(vac_dict["GchannelHigh"]),
            "B_Low":  self._down4096_to_256_float(vac_dict["BchannelLow"]),
            "B_High": self._down4096_to_256_float(vac_dict["BchannelHigh"]),
        }

        if not hasattr(self, "A_Gamma"):
            logging.error("[PredictOpt] Jacobian not prepared.")
            return None, None

        panel, fr, model_year = self._get_ui_meta()

        K   = len(self._jac_artifacts["knots"])
        Phi = self._stack_basis(self._jac_artifacts["knots"])

        # 이 변수들은 계속 12bit 스케일 유지
        high_R = lut256["R_High"].copy()
        high_G = lut256["G_High"].copy()
        high_B = lut256["B_High"].copy()

        for it in range(1, n_iters + 1):
            # ✅ 2️⃣ 여기서 예측에 넘길 때만 0~1 스케일로 정규화
            lut256_for_pred = {
                k: np.asarray(v, np.float32) / 4095.0 for k, v in {
                    "R_Low": lut256["R_Low"],
                    "G_Low": lut256["G_Low"],
                    "B_Low": lut256["B_Low"],
                    "R_High": high_R,
                    "G_High": high_G,
                    "B_High": high_B,
                }.items()
            }

            # ✅ 예측은 정규화된 LUT 사용
            y_pred = self._predict_Y0W_from_models(
                lut256_for_pred,
                panel_text=panel, frame_rate=fr, model_year=model_year
            )

            # (선택) 디버그용 CSV 저장
            self._debug_dump_predicted_Y0W(
                y_pred, tag=f"iter{it}_{panel}_fr{int(fr)}_my{int(model_year)%100:02d}", save_csv=True
            )

            # 이후 부분은 기존 그대로 유지
            d_targets = self._delta_targets_vs_OFF_from_pred(y_pred, self._off_store)
            A_cat = np.vstack([wG*self.A_Gamma, wC*self.A_Cx, wC*self.A_Cy]).astype(np.float32)
            b_cat = -np.concatenate([wG*d_targets["Gamma"], wC*d_targets["Cx"], wC*d_targets["Cy"]]).astype(np.float32)
            mask  = np.isfinite(b_cat)
            A_use = A_cat[mask,:]; b_use = b_cat[mask]
            ATA = A_use.T @ A_use
            rhs = A_use.T @ b_use
            ATA[np.diag_indices_from(ATA)] += float(lambda_ridge)
            delta_h = np.linalg.solve(ATA, rhs).astype(np.float32)

            dh_R = delta_h[0:K]; dh_G = delta_h[K:2*K]; dh_B = delta_h[2*K:3*K]
            corr_R = Phi @ dh_R; corr_G = Phi @ dh_G; corr_B = Phi @ dh_B

            # ✅ 보정은 12bit 스케일에서 수행
            high_R = np.clip(self._enforce_monotone(high_R + corr_R), 0, 4095)
            high_G = np.clip(self._enforce_monotone(high_G + corr_G), 0, 4095)
            high_B = np.clip(self._enforce_monotone(high_B + corr_B), 0, 4095)

            logging.info(f"[PredictOpt] iter {it} done. (wG={wG}, wC={wC})")

        # 이후 업샘플, UI 업데이트, JSON 빌드는 기존 코드 그대로

def _debug_dump_predicted_Y0W(self, y_pred: dict, *, tag: str = "", save_csv: bool = True):
    """
    예측된 'W' 패턴 256포인트 (Gamma, Cx, Cy)를 로그로 요약 + (옵션) CSV 저장

    Parameters
    ----------
    y_pred : {"Gamma": (256,), "Cx": (256,), "Cy": (256,)}
    tag    : 로그/파일명 식별용 태그 (예: "iter1_INX_60_Y26")
    save_csv : True면 임시 CSV 파일로 저장 후 경로 로깅
    """
    import numpy as np, pandas as pd, tempfile, os, logging

    # 안전 가드
    req_keys = ("Gamma", "Cx", "Cy")
    if not all(k in y_pred for k in req_keys):
        logging.warning(f"[Predict/Debug] y_pred keys invalid: {list(y_pred.keys())}")
        return

    g = np.asarray(y_pred["Gamma"], dtype=np.float32)
    cx= np.asarray(y_pred["Cx"],    dtype=np.float32)
    cy= np.asarray(y_pred["Cy"],    dtype=np.float32)

    # ── 1) 통계 요약 로그
    def _stat(a, name):
        with np.errstate(invalid="ignore"):
            logging.debug(f"[Predict/Debug] {name}: "
                          f"shape={a.shape}, mean={np.nanmean(a):.6g}, std={np.nanstd(a):.6g}, "
                          f"min={np.nanmin(a):.6g}, max={np.nanmax(a):.6g}")
    _stat(g, "Gamma")
    _stat(cx,"Cx")
    _stat(cy,"Cy")

    # ── 2) 특정 인덱스 원소 출력 (0,1,2,127,128,129,254,255)
    idx_probe = [0,1,2,127,128,129,254,255]
    for i in idx_probe:
        if 0 <= i < 256:
            logging.debug(f"[Predict/Debug] g={i:3d} | Gamma={g[i]!r:>12} | Cx={cx[i]:.6f} | Cy={cy[i]:.6f}")

    # ── 3) (옵션) CSV 저장
    if save_csv:
        df = pd.DataFrame({"Gamma": g, "Cx": cx, "Cy": cy})
        safe_tag = "".join(ch if ch.isalnum() or ch in ("-","_") else "_" for ch in str(tag))
        with tempfile.NamedTemporaryFile(prefix=f"y0W_{safe_tag}_", suffix=".csv", delete=False, mode="w", newline="", encoding="utf-8") as f:
            df.to_csv(f.name, index_label="Gray")
            csv_path = f.name
        logging.info(f"[Predict/Debug] Y0(W) 256pts saved → {csv_path}")
