# ----- [NEW] 예측-기반 내부 보정 루프 (가상 시뮬) -----
inner_max_iters = 3      # 내부 루프 횟수 (권장 2~3)
lambda_pred     = 1e-3   # 리지 안정화
eta             = 0.5    # 감쇠 스텝(0<eta≤1); 진동/오버슈트 방지

# 공통 준비물
K   = len(self._jac_artifacts["knots"])
Phi = self._stack_basis(self._jac_artifacts["knots"])  # (256,K)

# 관성 변수
best_candidate = { "R_High": high_256_new["R_High"].copy(),
                   "G_High": high_256_new["G_High"].copy(),
                   "B_High": high_256_new["B_High"].copy() }
best_score = float("inf")

for t in range(1, inner_max_iters+1):
    # 1) 현재 candidate LUT(정규화)로 Y0 예측
    low_256_norm = {
        "R_Low":  self._down4096_to_256(vac_lut["R_Low"]) / 4095.0,
        "G_Low":  self._down4096_to_256(vac_lut["G_Low"]) / 4095.0,
        "B_Low":  self._down4096_to_256(vac_lut["B_Low"]) / 4095.0,
    }
    high_256_norm = {
        "R_High": (high_256_new["R_High"] / 4095.0).astype(np.float32),
        "G_High": (high_256_new["G_High"] / 4095.0).astype(np.float32),
        "B_High": (high_256_new["B_High"] / 4095.0).astype(np.float32),
    }
    lut256_norm = {**low_256_norm, **high_256_norm}

    panel_name = self.ui.vac_cmb_PanelMaker.currentText().strip()
    frame_rate = float(self.ui.vac_cmb_FrameRate.currentText().strip())
    model_year = float(getattr(self, "current_model_year", 0.0))

    pred_y0_W = self._predict_Y0_W(
        lut256_norm=lut256_norm,
        panel_name=panel_name,
        panel_categories=PANEL_MAKER_CATEGORIES[0],
        frame_rate=frame_rate,
        model_year=model_year
    )

    # 2) 스펙 체크 (통과 → 내부 루프 종료)
    pred_ok = self._check_spec_with_prediction_W(
        self._off_store, pred_y0_W, thr_gamma=0.05, thr_c=0.003
    )
    # 점수(최대 오차) 계산해서 best 갱신
    def _pred_score(off_store, pred):
        lv_ref = np.zeros(256); cx_ref = np.zeros(256); cy_ref = np.zeros(256)
        for g in range(256):
            tup = off_store['gamma']['main']['white'].get(g, None)
            if tup: lv_ref[g], cx_ref[g], cy_ref[g] = tup
            else:   lv_ref[g]=np.nan; cx_ref[g]=np.nan; cy_ref[g]=np.nan
        G_ref = self._compute_gamma_series(lv_ref)
        dG  = np.nan_to_num(pred["Gamma"] - G_ref, nan=0.0)
        dCx = np.nan_to_num(pred["Cx"]    - cx_ref, nan=0.0)
        dCy = np.nan_to_num(pred["Cy"]    - cy_ref, nan=0.0)
        return max(float(np.max(np.abs(dG))),
                   float(np.max(np.abs(dCx))),
                   float(np.max(np.abs(dCy))))
    score = _pred_score(self._off_store, pred_y0_W)
    if score < best_score:
        best_score = score
        best_candidate = {k: v.copy() for k, v in high_256_new.items()}

    if pred_ok:
        logging.info(f"[PRED-LOOP] t={t}: ✅ 예측 스펙충족 — 내부 보정 종료")
        break

    # 3) 미통과라면, 예측 Δ를 타깃으로 추가 Δh 산출 → candidate LUT 업데이트
    #    ΔY_pred = (ON_pred - OFF)
    #    결합 선형계: A_cat Δh = - [wG*ΔGamma_pred; wC*ΔCx_pred; wC*ΔCy_pred]
    wG, wC = 1.0, 1.0
    # OFF baseline 만들기
    lv_ref = np.zeros(256); cx_ref = np.zeros(256); cy_ref = np.zeros(256)
    for g in range(256):
        tup = self._off_store['gamma']['main']['white'].get(g, None)
        if tup: lv_ref[g], cx_ref[g], cy_ref[g] = tup
        else:   lv_ref[g]=np.nan; cx_ref[g]=np.nan; cy_ref[g]=np.nan
    G_ref = self._compute_gamma_series(lv_ref)

    dGamma_pred = np.nan_to_num(pred_y0_W["Gamma"] - G_ref, nan=0.0).astype(np.float32)
    dCx_pred    = np.nan_to_num(pred_y0_W["Cx"]    - cx_ref, nan=0.0).astype(np.float32)
    dCy_pred    = np.nan_to_num(pred_y0_W["Cy"]    - cy_ref, nan=0.0).astype(np.float32)

    A_cat = np.vstack([wG*self.A_Gamma, wC*self.A_Cx, wC*self.A_Cy]).astype(np.float32)
    b_cat = -np.concatenate([wG*dGamma_pred, wC*dCx_pred, wC*dCy_pred]).astype(np.float32)

    mask = np.isfinite(b_cat)
    A_use = A_cat[mask, :]
    b_use = b_cat[mask]

    ATA = A_use.T @ A_use
    rhs = A_use.T @ b_use
    ATA[np.diag_indices_from(ATA)] += lambda_pred

    try:
        delta_h = np.linalg.solve(ATA, rhs).astype(np.float32)
    except np.linalg.LinAlgError:
        logging.warning("[PRED-LOOP] 선형계 특이 — 작은 정규화 추가 후 재시도")
        ATA[np.diag_indices_from(ATA)] += 1e-6
        delta_h = np.linalg.solve(ATA, rhs).astype(np.float32)

    dh_R = delta_h[0:K]; dh_G = delta_h[K:2*K]; dh_B = delta_h[2*K:3*K]
    corr_R = Phi @ dh_R;  corr_G = Phi @ dh_G;  corr_B = Phi @ dh_B

    # 감쇠 적용(eta)하여 업데이트
    high_256_new["R_High"] = (high_256_new["R_High"] + eta * corr_R).astype(np.float32)
    high_256_new["G_High"] = (high_256_new["G_High"] + eta * corr_G).astype(np.float32)
    high_256_new["B_High"] = (high_256_new["B_High"] + eta * corr_B).astype(np.float32)

    # 경계/단조/클램프
    for ch in ("R_High","G_High","B_High"):
        self._enforce_monotone(high_256_new[ch])
        high_256_new[ch] = np.clip(high_256_new[ch], 0, 4095)

# 내부 루프 종료 후: 통과 못했으면 best 후보 사용
if not pred_ok:
    logging.info(f"[PRED-LOOP] 내부 보정 후에도 예측 스펙 미충족 — best 후보로 진행 (score={best_score:.6f})")
    high_256_new = {k: v.copy() for k, v in best_candidate.items()}
# ---------------------------------------------



def _onehot_panel(self, name: str, categories: list[str]) -> np.ndarray:
    v = np.zeros(len(categories), np.float32)
    if name in categories:
        v[categories.index(name)] = 1.0
    return v

def _build_feature_for_gray_W(self, lut256_norm: dict, g: int,
                              panel_onehot: np.ndarray,
                              frame_rate: float,
                              model_year: float) -> np.ndarray:
    """
    train_Y0_models()에서 쓴 VACDataset.build_per_gray_y0()의 스키마와 동일하게 구성.
    feature = [R_Low[g],R_High[g],G_Low[g],G_High[g],B_Low[g],B_High[g],
               panel_onehot..., frame_rate, model_year,
               gray/255, pattern_onehot(4= 'W','R','G','B')]
    """
    row = [
        float(lut256_norm['R_Low'][g]),  float(lut256_norm['R_High'][g]),
        float(lut256_norm['G_Low'][g]),  float(lut256_norm['G_High'][g]),
        float(lut256_norm['B_Low'][g]),  float(lut256_norm['B_High'][g]),
    ]
    row.extend(panel_onehot.astype(np.float32).tolist())
    row.append(float(frame_rate))
    row.append(float(model_year))
    row.append(g / 255.0)
    # pattern='W' one-hot
    pat_oh = np.array([1.0, 0.0, 0.0, 0.0], dtype=np.float32)
    row.extend(pat_oh.tolist())
    return np.asarray(row, dtype=np.float32)

def _predict_Y0_W(self, lut256_norm: dict,
                  panel_name: str, panel_categories: list[str],
                  frame_rate: float, model_year: float) -> dict[str, np.ndarray]:
    """
    현재 LUT(정규화 0..1) 기준으로 white 패턴의 절대 Gamma/Cx/Cy를 256길이로 예측.
    self.models_Y0_bundle = {"Gamma":payload, "Cx":payload, "Cy":payload} 필요.
    payload는 train_hybrid_regressor의 반환 payload 구조( linear_model, rf_residual, target_scaler ).
    """
    # (a) 메타 인코딩
    panel_oh = self._onehot_panel(panel_name, PANEL_MAKER_CATEGORIES[0])  # ← 앱의 카테고리 리스트 사용

    # (b) 피처 행렬 구성 (256 x Dx)
    X_rows = [ self._build_feature_for_gray_W(lut256_norm, g, panel_oh, frame_rate, model_year)
               for g in range(256) ]
    X = np.vstack(X_rows).astype(np.float32)

    out = {}
    for comp in ("Gamma", "Cx", "Cy"):
        payload = self.models_Y0_bundle[comp]
        lin = payload["linear_model"]
        rf  = payload["rf_residual"]
        ts  = payload.get("target_scaler", {"standardized": True, "mean": 0.0, "std": 1.0})
        # 1단계 + 잔차
        base_s = lin.predict(X).astype(np.float32)
        resid_s = rf.predict(X).astype(np.float32)
        y_s = base_s + resid_s
        # 표준화 역변환
        if ts.get("standardized", True):
            y = y_s * float(ts.get("std", 1.0)) + float(ts.get("mean", 0.0))
        else:
            y = y_s
        out[comp] = y.astype(np.float32)
    return out

def _check_spec_with_prediction_W(self, off_store, pred_on_y0_W: dict[str, np.ndarray],
                                  thr_gamma=0.05, thr_c=0.003) -> bool:
    # OFF baseline (white/main)에서 Gamma/Cx/Cy 시퀀스 추출
    lv_ref = np.zeros(256); cx_ref = np.zeros(256); cy_ref = np.zeros(256)
    for g in range(256):
        tup = off_store['gamma']['main']['white'].get(g, None)
        if tup: lv_ref[g], cx_ref[g], cy_ref[g] = tup
        else:   lv_ref[g]=np.nan; cx_ref[g]=np.nan; cy_ref[g]=np.nan
    G_ref = self._compute_gamma_series(lv_ref)

    # 예측된 ON 절대 (white)
    G_on_pred = pred_on_y0_W["Gamma"]
    Cx_on_pred = pred_on_y0_W["Cx"]
    Cy_on_pred = pred_on_y0_W["Cy"]

    # Δ 계산 (NaN 방어)
    dG  = np.abs(np.nan_to_num(G_on_pred - G_ref, nan=0.0))
    dCx = np.abs(np.nan_to_num(Cx_on_pred - cx_ref, nan=0.0))
    dCy = np.abs(np.nan_to_num(Cy_on_pred - cy_ref, nan=0.0))

    max_dG  = float(np.nanmax(dG))
    max_dCx = float(np.nanmax(dCx))
    max_dCy = float(np.nanmax(dCy))

    logging.info(f"[PRED SPEC] max|ΔGamma|={max_dG:.6f} (≤{thr_gamma}), "
                 f"max|ΔCx|={max_dCx:.6f}, max|ΔCy|={max_dCy:.6f} (≤{thr_c})")
    return (max_dG <= thr_gamma) and (max_dCx <= thr_c) and (max_dCy <= thr_c)


# ----- [NEW] 예측모델로 사전 검증 게이트 -----
try:
    # 정규화(0..1)된 256포인트 LUT 준비 (Low: 캐시에서 다운샘플→/4095, High: 보정후→/4095)
    low_256_norm = {
        "R_Low":  self._down4096_to_256(vac_lut["R_Low"])  / 4095.0,
        "G_Low":  self._down4096_to_256(vac_lut["G_Low"])  / 4095.0,
        "B_Low":  self._down4096_to_256(vac_lut["B_Low"])  / 4095.0,
    }
    high_256_norm = {
        "R_High": (high_256_new["R_High"] / 4095.0).astype(np.float32),
        "G_High": (high_256_new["G_High"] / 4095.0).astype(np.float32),
        "B_High": (high_256_new["B_High"] / 4095.0).astype(np.float32),
    }
    lut256_norm = {**low_256_norm, **high_256_norm}

    # 메타: 패널/주사율/연도 (UI에서 사용 중인 값 재사용)
    panel_name  = self.ui.vac_cmb_PanelMaker.currentText().strip()
    frame_rate  = float(self.ui.vac_cmb_FrameRate.currentText().strip())
    # model_year는 없으면 보수적으로 0 또는 최근 연도로 설정
    try:
        model_year = float(getattr(self, "current_model_year", 0.0))
    except Exception:
        model_year = 0.0

    # 예측
    pred_y0_W = self._predict_Y0_W(
        lut256_norm=lut256_norm,
        panel_name=panel_name,
        panel_categories=PANEL_MAKER_CATEGORIES[0],
        frame_rate=frame_rate,
        model_year=model_year
    )

    # 스펙 게이트
    if self._check_spec_with_prediction_W(self._off_store, pred_y0_W,
                                          thr_gamma=0.05, thr_c=0.003):
        logging.info("[PRED] ✅ 예측 스펙-IN → TV에 적용 진행")
        do_apply = True
    else:
        logging.info("[PRED] ❌ 예측 스펙-OUT → 파라미터 조정(예: λ↑) 후 재시도 또는 스킵")
        # 간단 전략: λ(리지) 증가 후 한 번 더 풀기 → 필요 없으면 False로 그냥 측정 단계로 가도 됨
        # 여기서는 일단 적용을 진행하지 않고, 다음 이터레이션/전략으로 넘기고 싶다면:
        # return  혹은  do_apply = False 로 분기
        do_apply = True  # <- 처음엔 실제 거동 확인 위해 True 유지 권장
except Exception as e:
    logging.exception(f"[PRED] 사전 예측 검증 중 오류: {e}")
    do_apply = True  # 안전하게 계속 진행
# ---------------------------------------------

try:
    models_dir = cf.get_normalized_path(__file__, '.', 'models')
    self.models_Y0_bundle = {
        "Gamma": joblib.load(os.path.join(models_dir, "hybrid_Gamma_model.pkl")),
        "Cx":    joblib.load(os.path.join(models_dir, "hybrid_Cx_model.pkl")),
        "Cy":    joblib.load(os.path.join(models_dir, "hybrid_Cy_model.pkl")),
    }
    logging.info("[Predict] Hybrid Y0 models loaded.")
except Exception as e:
    logging.exception("[Predict] Failed to load Y0 models.")
    self.models_Y0_bundle = None

if not getattr(self, "models_Y0_bundle", None):
    logging.warning("[PRED] Y0 예측모델이 없어 사전 검증을 생략합니다.")


